<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/05/05/hello-world/</url>
    <content><![CDATA[<center>我记得有些路是我一个人走过来的</center>

<center>路很黑</center>

<center>风也很大</center>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>epsilon-约束方法</title>
    <url>/2024/05/06/epsilon-%E7%BA%A6%E6%9D%9F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="varepsilon-约束方法（这样GUROBI也能解多目标问题了！）"><a href="#varepsilon-约束方法（这样GUROBI也能解多目标问题了！）" class="headerlink" title="$\varepsilon$-约束方法（这样GUROBI也能解多目标问题了！）"></a>$\varepsilon$-约束方法（这样GUROBI也能解多目标问题了！）</h1><p>一般解决多目标优化问题的算法都是NSGA-II算法、MOEA-D算法等多目标智能算法。采用Gurobi精确求解的方法往往难以求出pareto最优解，只能通过对多个目标进行加权的方式求解。今天我们学习一种方法，借助它我们也可以使用Gurobi等求解工具求解多目标优化算法，且其求解效果比加权法更好。</p>
<p><img src="/../images/image-20240304112349257.png"></p>
<hr>
<h2 id="varepsilon-约束方法简介"><a href="#varepsilon-约束方法简介" class="headerlink" title="$\varepsilon$-约束方法简介"></a>$\varepsilon$-约束方法简介</h2><p>$\varepsilon$-约束方法是一种多目标优化算法。它基于约束优化的思想，通过引入一个参数$\varepsilon$来控制目标函数的权重，从而保证满足约束条件的前提下，寻找到最优解的近似解集。</p>
<p>通过选取一个主目标函数，将其余目标函数转化为约束，从而计算每个子优化目标，得到帕累托解集。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>针对一个多目标优化问题：<br>$$<br>min {f_1(x),f_2(x),f_3(x)} \<br>h(x)&#x3D;0 \<br>g(x)\leq 0<br>$$</p>
<p>使用ε约束算法转化问题为：<br>$$<br>min f_1(x) \<br>f_2(x)\leq \epsilon_2,\cdots,f_n(x)\leq\epsilon_n \<br>h(x) &#x3D; 0 \<br>g(x) \leq 0<br>$$<br>其中的每个参数$\epsilon_2,\epsilon_3,\cdots,\epsilon_n$通过计算payoff矩阵得到。</p>
<p>payoff的计算过程：</p>
<ol>
<li><p>求解出第i个目标函数的最优值$f_i(x_i^*)$，得到其最优解$x_i^*$；</p>
</li>
<li><p>将$x_i^*$代入其他目标函数得到${f_1(x_i^*),f_2(x_i^*),\cdots,f_n(x_i^*)}$；</p>
</li>
<li><p>对全部目标函数按照上述流程求解，得到payoff table矩阵如下：<br>$$<br>\begin{bmatrix}<br>f_1(x_1^*) &amp; \cdots &amp; f_i(x_1^*) &amp;\cdots &amp; f_n(x_1^*)\<br>\vdots&amp; \ddots &amp;&amp;&amp; \vdots\<br>f_1(x_i^*) &amp; \cdots &amp; f_i(x_i^*) &amp;\cdots &amp; f_n(x_i^*)\<br>\vdots&amp; \ddots&amp; &amp; &amp; \vdots \<br>f_1(x_n^*) &amp; \cdots &amp; f_i(x_n^*) &amp;\cdots &amp; f_n(x_n^*)\<br>\end{bmatrix}<br>$$</p>
</li>
</ol>
<p>该方法本质上与网格搜索法相同。得到了payoff矩阵之后，可以求出每个目标的最优值和最劣值（就是每个目标维度的最大和最小值）。记为最优解(U)和最劣解(SN)$f_i^U &#x3D; f_i(x_i^*)$,$f_i^{SN} &#x3D; f_i(x_j^*)$。</p>
<p>选择一个主目标函数$f_k(x)$。</p>
<p>对于主目标函数外的目标函数$f_{i}(x)$，设置一个网格化分数$q_{ij}∈{1,2,\cdots,q_i,max} $。</p>
<p>由此计算除了主目标函数外的其余目标函数的ε约束如下：<br>$$<br>ϵ_{ij}&#x3D;f_i^{SN}−\frac{(f_i^{SN}−f_i^{U})}{q_{ij}}⋅j \qquad j&#x3D;1,2,…,q_{i,max}<br>$$<br>得到每个优化子问题如下：<br>$$<br>min f_k(x)\<br>s.t. \qquad f_1(x)\leq \epsilon_{1j},f_2(x)\leq \epsilon_{1l},f_n(x)\leq \epsilon_{1m},h(x)&#x3D;0,g(x)\leq0<br>$$<br>其中,$j&#x3D;1,2,\cdots,q_{1,max};l&#x3D;1,2,\cdots,q_{2,max};\cdots;m&#x3D;1,2,\cdots,q_{n,max};$</p>
<p>每次求出一个最优解，若在可行域内则加入帕累托解集，若不在可行域内则丢弃。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>$$<br>min \quad f_1(x) &#x3D; x_2-x_1 \<br>min \quad f_2(x) &#x3D; x_1+x_2 \<br>s.t. \qquad x_1^2 - 2x_1 + 1 \leq x_2 \<br>0 \leq x_1 \leq 1 \<br>0 \leq x_2 \leq 1<br>$$</p>
<p>使用python+gurobi求解代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2024/3/3 11:35</span></span><br><span class="line"><span class="comment"># @Author  : TUUG</span></span><br><span class="line"><span class="comment"># @Email   : tr6666666@qq.com</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> gurobipy <span class="keyword">as</span> gp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">constraint=<span class="literal">None</span></span>):</span><br><span class="line">    model = gp.Model()</span><br><span class="line">    x1 = model.addVar(name=<span class="string">&quot;X1&quot;</span>,vtype=gp.GRB.CONTINUOUS,lb=<span class="number">0</span>,ub=<span class="number">1</span>)</span><br><span class="line">    x2 = model.addVar(name=<span class="string">&quot;X2&quot;</span>,vtype=gp.GRB.CONTINUOUS,lb=<span class="number">0</span>,ub=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 添加约束</span></span><br><span class="line">    model.addConstr(x1*x1-<span class="number">2</span>*x1+<span class="number">1</span>&lt;=x2)</span><br><span class="line">    <span class="keyword">if</span> constraint <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        model.addConstr(x1+x2&lt;=constraint)</span><br><span class="line">    <span class="comment"># 定义目标函数</span></span><br><span class="line">    model.setObjective(x2-x1, sense = gp.GRB.MINIMIZE)</span><br><span class="line">    model.update()</span><br><span class="line">    <span class="comment"># 求解模型</span></span><br><span class="line">    model.optimize()</span><br><span class="line">    <span class="keyword">return</span> x1.x,x2.x</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="comment"># 创建模型</span></span><br><span class="line">    m2 = gp.Model(<span class="string">&quot;f2_optimization&quot;</span>)</span><br><span class="line">    <span class="comment"># 定义变量</span></span><br><span class="line">    x1 = m2.addVar(name=<span class="string">&quot;X1&quot;</span>,vtype=gp.GRB.CONTINUOUS,lb=<span class="number">0</span>,ub=<span class="number">1</span>)</span><br><span class="line">    x2 = m2.addVar(name=<span class="string">&quot;X2&quot;</span>,vtype=gp.GRB.CONTINUOUS,lb=<span class="number">0</span>,ub=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 添加约束</span></span><br><span class="line">    m2.addConstr(x1*x1-<span class="number">2</span>*x1+<span class="number">1</span>&lt;=x2)</span><br><span class="line">    <span class="comment"># model.addConstr(x2-x1&gt;=cons)</span></span><br><span class="line">    <span class="comment"># 定义目标函数</span></span><br><span class="line">    m2.setObjective(x2+x1, sense = gp.GRB.MINIMIZE)</span><br><span class="line">    <span class="comment"># 求解模型</span></span><br><span class="line">    m2.optimize()</span><br><span class="line">    <span class="keyword">return</span> x1.x,x2.x</span><br><span class="line"></span><br><span class="line">f11,f12 = f1()</span><br><span class="line">f21,f22 = f2()</span><br><span class="line">f1_min = f12-f11</span><br><span class="line">f2_max = f11+f12</span><br><span class="line">f2_min = f21+f22</span><br><span class="line">f1_max = f22-f21</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f2_min,f2_max)</span><br><span class="line">soultion_pool = []</span><br><span class="line">q_n =<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(q_n):</span><br><span class="line">    constraint = f2_max-(f2_max-f2_min)/q_n*q</span><br><span class="line">    <span class="comment"># constraint = np.linspace(f2_min,f2_max,10)[q]</span></span><br><span class="line">    f11,f12 = f1(constraint=constraint)</span><br><span class="line">    soultion_pool.append([f12-f11,f11+f12])</span><br><span class="line"><span class="built_in">print</span>(soultion_pool)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">pareto_front_solutions = np.array(soultion_pool)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 Pareto 前沿解</span></span><br><span class="line">plt.scatter(pareto_front_solutions[:, <span class="number">0</span>], pareto_front_solutions[:, <span class="number">1</span>], label=<span class="string">&#x27;Pareto Front&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;f1(x)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;f2(x)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Pareto Front for Multi-objective Optimization&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>求解结果展示如下</p>
<p>网格化分数取10时：</p>
<p><img src="/../images/image-20240304112820159.png"></p>
<p>网格化分数取20时：</p>
<p><img src="/../images/image-20240304112906514.png"></p>
<p>网格化分数取100时：</p>
<p><img src="/../images/image-20240304112938975.png"></p>
<p>可以看到，这个方法有一个很好的性质，就是可以通过增大网格化分数来改善求解结果，使其更接近真实帕累托前沿。如果求解时间过长可以减小网格化分数来缩短求解时间。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Ismail-Yahaya A, Messac A. Effective generation of the Pareto frontier using the normal constraint method[C]&#x2F;&#x2F;40th AIAA Aerospace Sciences Meeting &amp; Exhibit. 2002: 178.</p>
<p>[2] Fan Z, Li W, Cai X, et al. An improved epsilon constraint-handling method in MOEA&#x2F;D for CMOPs with large infeasible regions[J]. Soft Computing, 2019, 23: 12491-12510.</p>
<p>[3] Yang Z, Cai X, Fan Z. Epsilon constrained method for constrained multi-objective optimization problems: some preliminary results[C]&#x2F;&#x2F;Proceedings of the companion publication of the 2014 annual conference on genetic and evolutionary computation. 2014: 1181-1186.</p>
<p>[4]  <a href="https://blog.csdn.net/weixin_44786238/article/details/126068290">【多目标规划问题求解】ε-约束算法_约束法多目标规划问题求解-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>精确优化方法</tag>
      </tags>
  </entry>
  <entry>
    <title>资源受限项目调度程序RCPSP</title>
    <url>/2024/05/06/%E8%B5%84%E6%BA%90%E5%8F%97%E9%99%90%E9%A1%B9%E7%9B%AE%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8FRCPSP/</url>
    <content><![CDATA[<h1 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h1><p>资源受限项目调度问题（Resource-Constrained Project Scheduling Problem，RCPSP）是一个经典的优化问题，涉及在有限资源的情况下安排项目任务，以最大化某种指标，比如项目完成时间、资源利用率或成本最小化等。在许多实际应用中，资源受限是常见的，例如在制造业、建筑业、信息技术和项目管理等领域。</p>
<p>在资源受限项目调度问题中，通常会给定以下几个方面的限制和条件：</p>
<ol>
<li>任务： 项目被分解为一系列可执行的任务，每个任务都有一个开始时间和结束时间。 </li>
<li>资源：项目所需的资源包括人力、设备、资金等，这些资源是有限的。 </li>
<li>约束： 每个任务对资源的需求是不同的，同时存在任务之间的先后顺序和依赖关系。</li>
<li>优化目标： 最常见的优化目标是最小化项目完成时间或最大化资源利用率，但也可能涉及其他目标，比如最小化成本或最大化利润等。</li>
</ol>
<p>资源受限项目调度问题是一个NP-难问题，因此没有多项式时间的解法。解决该问题的方法通常包括：</p>
<ol>
<li>启发式算法： 基于经验或直觉设计的算法，如遗传算法、模拟退火等。 </li>
<li>精确算法： 尝试找到最优解的算法，如动态规划、分支定界等。但这些算法在大规模问题上的效率通常较低。 混合方法。</li>
<li>结合启发式算法和精确算法，以在可接受的时间内找到较好的解决方案。</li>
</ol>
<p>资源受限项目调度问题在许多实际应用中都有广泛的应用，包括但不限于：</p>
<ol>
<li>生产制造： 在生产线上安排任务以最大化产量并最小化成本。</li>
<li>建筑业： 安排施工工序和资源以优化工程进度和资源利用率。 </li>
<li>信息技术：安排软件开发项目中的任务和团队资源。 </li>
<li>项目管理： 规划和安排复杂项目中的任务和资源分配。</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>某个项目包含9个活动，活动间先后关系如图所示：<br><img src="/../images/%E6%B4%BB%E5%8A%A8%E4%BC%98%E5%85%88%E5%85%B3%E7%B3%BB.png"><br>各活动工期如下：</p>
<table>
<thead>
<tr>
<th>活动</th>
<th>活动名称</th>
<th>活动持续时间</th>
<th>资源需求量</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>活动1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>活动2</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>活动3</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>活动4</td>
<td>6</td>
<td>10</td>
</tr>
<tr>
<td>5</td>
<td>活动5</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>6</td>
<td>活动6</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>活动7</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>活动8</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>活动9</td>
<td>7</td>
<td>5</td>
</tr>
</tbody></table>
<h1 id="启发规则求解"><a href="#启发规则求解" class="headerlink" title="启发规则求解"></a>启发规则求解</h1><p>采用最短工期活动最先开始调度规则，生成上述问题的结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Author: TUUG</span></span><br><span class="line"><span class="string">Date: April 26, 2024 20:59</span></span><br><span class="line"><span class="string">Description: 求解资源受限项目调度问题并画图.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.labelsize&quot;</span>]=<span class="number">14</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;xtick.labelsize&quot;</span>]=<span class="number">12</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;ytick.labelsize&quot;</span>]=<span class="number">12</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号&#x27;-&#x27;显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Activity</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    活动类：包含  1.活动ID  2.活动持续时间    3.活动资源需求量   4.活动紧前活动    5.活动最早开始时间  6.活动最晚开始时间  7.活动是否被访问</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">id</span>, duration, resourceRequest, successor</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.time_long = duration  <span class="comment"># 活动总时长，固定不变</span></span><br><span class="line">        self.duration = duration  <span class="comment"># 活动剩余时长，动态变化</span></span><br><span class="line">        self.resourceRequest = np.array(resourceRequest)[<span class="number">0</span>]</span><br><span class="line">        self.predecessor = <span class="literal">None</span></span><br><span class="line">        self.successor = successor</span><br><span class="line">        self.visited = <span class="literal">False</span></span><br><span class="line">        self.start = <span class="literal">None</span>  <span class="comment"># 这里的start是时点数据，不是时段数据</span></span><br><span class="line">        self.end = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Day</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,<span class="built_in">id</span>,total_resource</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line">        self.total_resource = total_resource</span><br><span class="line">        self.resource_used = <span class="number">0</span></span><br><span class="line">        self.resource_left = total_resource</span><br><span class="line">        self.act_list = []</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#================修改代码=====================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_act</span>(<span class="params">act,day,days</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;启动活动&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> act.visited == <span class="literal">False</span>:</span><br><span class="line">        act.visited = <span class="literal">True</span></span><br><span class="line">        act.start = day.<span class="built_in">id</span>-<span class="number">1</span></span><br><span class="line">        act.end = act.start + act.time_long</span><br><span class="line">        <span class="comment"># 如果活动时长大于0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(act.time_long):</span><br><span class="line">            execute_act(act,days[days.index(day)+i])  <span class="comment"># 这里替换为执行活动函数</span></span><br><span class="line">        <span class="keyword">if</span> act.time_long == <span class="number">0</span>:</span><br><span class="line">            execute_act(act,day)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">execute_act</span>(<span class="params">act,day</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;执行活动&quot;&quot;&quot;</span></span><br><span class="line">    act.duration -= <span class="number">1</span></span><br><span class="line">    day.resource_used += act.resourceRequest</span><br><span class="line">    day.resource_left -= act.resourceRequest</span><br><span class="line">    day.act_list.append(act.<span class="built_in">id</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">can_start1</span>(<span class="params">act,day,days</span>):</span><br><span class="line">    <span class="comment"># 判断一个活动是否能开始，条件1：资源是否足够</span></span><br><span class="line">    a = days.index(day)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(act.time_long):</span><br><span class="line">        <span class="keyword">if</span> days[<span class="built_in">min</span>(a+j,<span class="built_in">len</span>(days)-<span class="number">1</span>)].resource_left &lt; act.resourceRequest:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">can_start2</span>(<span class="params">act,act_done</span>):</span><br><span class="line">    <span class="comment"># 判断一个活动是否能开始，条件2：该活动的前序活动是否已经完成</span></span><br><span class="line">    <span class="keyword">for</span> preAct <span class="keyword">in</span> act.predecessor:</span><br><span class="line">        <span class="keyword">if</span> preAct <span class="keyword">not</span> <span class="keyword">in</span> act_done:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_done</span>(<span class="params">act,act_done,activities</span>):</span><br><span class="line">    <span class="comment"># 判断活动的所有前序活动是否都已完成，返回0则说明都已经完成</span></span><br><span class="line">    ans = [<span class="number">0</span> <span class="keyword">if</span> activities[i] <span class="keyword">in</span> act_done <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> act.predecessor]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(ans) </span><br><span class="line">    <span class="comment">#================修改代码=====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data_from_RCP_file</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    读取标准化文件中的所有活动信息，包括  1.活动数   2.项目资源数 3.项目资源种类数   4.项目资源限量</span></span><br><span class="line"><span class="string">    5.所有活动的ID，持续时间，资源需求，紧前活动</span></span><br><span class="line"><span class="string">    :param fileName:</span></span><br><span class="line"><span class="string">    :return: 标准化文件数据</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(file_name)</span><br><span class="line">    taskAndResourceType = f.readline().split(<span class="string">&#x27;      &#x27;</span>)  <span class="comment"># 第一行数据包含活动数和资源数</span></span><br><span class="line">    num_activities = <span class="built_in">int</span>(taskAndResourceType[<span class="number">0</span>])  <span class="comment"># 得到活动数</span></span><br><span class="line">    num_resource_type = <span class="built_in">int</span>(taskAndResourceType[<span class="number">1</span>])  <span class="comment"># 得到资源数</span></span><br><span class="line">    total_resource = np.array([<span class="built_in">int</span>(value) <span class="keyword">for</span> value <span class="keyword">in</span> f.readline().split(<span class="string">&#x27;      &#x27;</span>)[:-<span class="number">1</span>]])  <span class="comment"># 获取资源限量</span></span><br><span class="line">    <span class="comment"># 将每个活动的所有信息存入到对应的Activity对象中去</span></span><br><span class="line">    activities = &#123;&#125;</span><br><span class="line">    preActDict = defaultdict(<span class="keyword">lambda</span>: [])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_activities):</span><br><span class="line">        nextLine = [<span class="built_in">int</span>(value) <span class="keyword">for</span> value <span class="keyword">in</span> f.readline().split(<span class="string">&#x27;      &#x27;</span>)[:-<span class="number">1</span>]]</span><br><span class="line">        <span class="comment"># task = Activity(i + 1, nextLine[0], nextLine[1:5], nextLine[6:])</span></span><br><span class="line">        task = Activity(i + <span class="number">1</span>, nextLine[<span class="number">0</span>], nextLine[<span class="number">1</span>:<span class="number">2</span>], nextLine[<span class="number">3</span>:])</span><br><span class="line">        activities[task.<span class="built_in">id</span>] = task</span><br><span class="line">        <span class="comment"># for act in nextLine[6:]:</span></span><br><span class="line">        <span class="keyword">for</span> act <span class="keyword">in</span> nextLine[<span class="number">3</span>:]:</span><br><span class="line">            preActDict[act].append(i + <span class="number">1</span>)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="comment"># 给每个活动加上紧前活动信息</span></span><br><span class="line">    <span class="keyword">for</span> actKey <span class="keyword">in</span> activities.keys():</span><br><span class="line">        activities[actKey].predecessor = preActDict[activities[actKey].<span class="built_in">id</span>].copy()</span><br><span class="line">    <span class="keyword">return</span> num_activities, num_resource_type, total_resource, activities  </span><br><span class="line"></span><br><span class="line">file_name = <span class="string">r&#x27;D:/python代码库/实验/mv9.rcp&#x27;</span></span><br><span class="line">num_activities, num_resource_type, total_resource, activities = read_data_from_RCP_file(file_name)</span><br><span class="line">total_resource = total_resource[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line">num_days = <span class="built_in">sum</span>([i.duration <span class="keyword">for</span> i <span class="keyword">in</span> activities.values()]) <span class="comment"># 总天数自动计算，不再需要手动指定</span></span><br><span class="line"><span class="comment"># num_days = 150</span></span><br><span class="line">days = [Day(i,total_resource) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num_days+<span class="number">1</span>)]</span><br><span class="line">act_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> activities.values()]</span><br><span class="line">act_done = []</span><br><span class="line">act_candidate = [activities[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="comment"># ----------调度核心逻辑-------</span></span><br><span class="line"><span class="keyword">for</span> day <span class="keyword">in</span> days:</span><br><span class="line">    <span class="comment"># 首先考虑工期为0的活动</span></span><br><span class="line">    <span class="keyword">for</span> act <span class="keyword">in</span> act_candidate:</span><br><span class="line">        <span class="keyword">if</span> act.time_long == <span class="number">0</span>:</span><br><span class="line">            act.start = day.<span class="built_in">id</span>-<span class="number">1</span></span><br><span class="line">            act.end = day.<span class="built_in">id</span>-<span class="number">1</span></span><br><span class="line">            act_done.append(act)</span><br><span class="line">            act_candidate.remove(act)</span><br><span class="line">            <span class="comment"># act_candidate.append(act.successor)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> act.successor:</span><br><span class="line">                act_candidate.append(activities[i])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历act_candidate列表,将能开启的工作全部启动</span></span><br><span class="line">    <span class="keyword">for</span> act <span class="keyword">in</span> act_candidate:</span><br><span class="line">        <span class="keyword">if</span> can_start1(act,day,days):</span><br><span class="line">            start_act(act,day,days)</span><br><span class="line">    <span class="comment"># -------更新act_done列表-----</span></span><br><span class="line">    <span class="keyword">for</span> act <span class="keyword">in</span> act_list:</span><br><span class="line">        <span class="keyword">if</span> act.end:</span><br><span class="line">            <span class="keyword">if</span> act.end &lt;= day.<span class="built_in">id</span> <span class="keyword">and</span> act <span class="keyword">not</span> <span class="keyword">in</span> act_done:</span><br><span class="line">                act_done.append(act)</span><br><span class="line">    <span class="comment"># 更新act_candidate列表</span></span><br><span class="line">    <span class="keyword">for</span> act <span class="keyword">in</span> act_candidate:</span><br><span class="line">        <span class="keyword">for</span> suc <span class="keyword">in</span> act.successor:</span><br><span class="line">            <span class="keyword">if</span> pre_done(activities[suc],act_done,activities) == <span class="number">0</span>:</span><br><span class="line">                act_candidate.append(activities[suc])       </span><br><span class="line">    <span class="keyword">for</span> act <span class="keyword">in</span> act_candidate:</span><br><span class="line">        <span class="keyword">if</span> act <span class="keyword">in</span> act_done:</span><br><span class="line">            act_candidate.remove(act)</span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_square</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="comment"># plt.figure(figsize=(8, 8))</span></span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    cmap = plt.get_cmap(<span class="string">&#x27;viridis&#x27;</span>)  <span class="comment"># 使用 &#x27;viridis&#x27; colormap，你可以根据需要选择其他colormap</span></span><br><span class="line">    norm = plt.Normalize(vmin=<span class="number">0</span>, vmax=matrix.<span class="built_in">max</span>())  <span class="comment"># 指定归一化范围</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(matrix.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(matrix.shape[<span class="number">1</span>]):</span><br><span class="line">            color = cmap(norm(matrix[i, j]))</span><br><span class="line">            <span class="keyword">if</span> matrix[i, j] == <span class="number">0</span>:</span><br><span class="line">                color = <span class="string">&#x27;white&#x27;</span></span><br><span class="line">            square = plt.Rectangle((j, total_resource-<span class="number">1</span>-i), <span class="number">1</span>, <span class="number">1</span>, fill=<span class="literal">True</span>, color=color, edgecolor=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">            ax.add_patch(square)</span><br><span class="line">            <span class="keyword">if</span> matrix[i, j] != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 在正方形中心位置添加数字</span></span><br><span class="line">                plt.text(j + <span class="number">0.5</span>, total_resource-<span class="number">1</span>-i + <span class="number">0.5</span>, <span class="built_in">str</span>(matrix[i, j]), color=<span class="string">&#x27;black&#x27;</span>,fontsize=<span class="number">12</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">    ax.set_xlim(<span class="number">0</span>, matrix.shape[<span class="number">1</span>])</span><br><span class="line">    ax.set_ylim(<span class="number">0</span>, matrix.shape[<span class="number">0</span>])</span><br><span class="line">    ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>, adjustable=<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;日期&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;资源&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;项目调度图&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line">ans = [days[i].act_list <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_days)]</span><br><span class="line">ans.remove([])</span><br><span class="line">b = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(activities)):</span><br><span class="line">    b[i+<span class="number">1</span>] = activities[i+<span class="number">1</span>].resourceRequest</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy</span>(<span class="params">sub_ans,b</span>):</span><br><span class="line">    result = [item <span class="keyword">for</span> item <span class="keyword">in</span> sub_ans <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(b.get(item, <span class="number">1</span>))]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">ans_new = [[]] * <span class="built_in">len</span>(ans)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans)):</span><br><span class="line">    ans_new[i] = copy(ans[i],b)</span><br><span class="line"><span class="comment"># print(ans_new)</span></span><br><span class="line"><span class="comment"># print(&#x27;--------------各活动开始时间----------------&#x27;)</span></span><br><span class="line">start_time = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(activities)+<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># print(&#x27;活动&#x27;+str(i)+&#x27;开始于&#x27;+str(activities[i].start))</span></span><br><span class="line">    start_time.append(activities[i].start)</span><br><span class="line"><span class="comment"># print(start_time)</span></span><br><span class="line"><span class="comment"># print(&#x27;-------------活动总工期----------------&#x27;)</span></span><br><span class="line">total_time = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(activities)+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> activities[i].successor == []:</span><br><span class="line">        total_time = activities[i].end+<span class="number">1</span></span><br><span class="line"><span class="comment"># print(total_time)</span></span><br><span class="line"><span class="comment"># 转成矩阵</span></span><br><span class="line">a = np.zeros((total_resource,<span class="built_in">len</span>(ans_new)),dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans_new)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans_new[i])):</span><br><span class="line">        a[total_resource-<span class="number">1</span>-j,i] = <span class="built_in">int</span>(ans_new[i][j])</span><br><span class="line"></span><br><span class="line">plot_square(a)</span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="求解结果"><a href="#求解结果" class="headerlink" title="求解结果"></a>求解结果</h1><p>采用上述代码求解的项目调度图如图所示：<br><img src="/../images/%E9%BB%98%E8%AE%A4%E9%A1%BA%E5%BA%8F%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88.png"></p>
<p>采用最短时间活动最先开始规则生成图如下：<br><img src="/../images/%E5%90%AF%E5%8F%91%E8%A7%84%E5%88%99%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88.png"></p>
]]></content>
      <tags>
        <tag>项目调度，启发式规则</tag>
      </tags>
  </entry>
  <entry>
    <title>本地部署Graphhopper实现离线地图路径规划功能（小白放心食用版）</title>
    <url>/2024/05/06/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Graphhopper%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E5%9C%B0%E5%9B%BE%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E5%8A%9F%E8%83%BD%EF%BC%88%E5%B0%8F%E7%99%BD%E6%94%BE%E5%BF%83%E9%A3%9F%E7%94%A8%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>最近几天一直在做一个CVRP问题，需要计算两点之间的路径距离与时间，直接采用经纬度计算直线距离会有很大的误差。正常来说，直接调用百度或者高德地图提供的API接口即可轻松实现，但是由于项目最终需要部署在内网，所以只能采用离线地图来计算路径距离。</p>
<p>作为一个完全没接触过离线地图的小白，接到这个任务后内心是崩溃的。在找了无数的教程、看了无数的文档、踩了无数的坑之后，终于实现了这一功能，必须记录一下。</p>
<p>首先是工具与技术路线的选择，作为小白，经过一通搜索后，下载了无数的软件后，终于明白了，要做到离线路径规划或者导航，必须要有两要素。首先是地图数据（一般是地图瓦片，格式为jpg或者png，这里必须注意百度地图瓦片编号与高德地图瓦片编号规则是不同的！！！）以及路网数据（一般为pbf等格式），然后是本地服务（就是根据地图数据实现路径规划的算法等服务）。确定好需要的工具以及数据后，咱们直接开始！</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3><p>地图数据去这里<a href="https://www.openstreetmap.org/%E6%88%96%E8%80%85%E8%BF%99%E9%87%8C[Geofabrik">https://www.openstreetmap.org/或者这里[Geofabrik</a> Download Server](<a href="https://download.geofabrik.de/)%E4%B8%8B%E8%BD%BD%E3%80%82%E6%AF%94%E5%A6%82%E6%88%91%E9%9C%80%E8%A6%81%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9A%84%E5%9C%B0%E5%9B%BE%E8%B7%AF%E7%BD%91%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B0%B1%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA%E2%80%99zhejiang-latest.osm.pbf%E2%80%98%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82%E8%BF%99%E9%87%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%AD%A4%E4%B8%8B%E8%BD%BD%E6%B5%99%E6%B1%9F%E7%9C%81%E5%9C%B0%E5%9B%BE%E6%95%B0%E6%8D%AE%E3%80%82">https://download.geofabrik.de/)下载。比如我需要浙江省的地图路网数据，就下载一个名为’zhejiang-latest.osm.pbf‘的文件。这里也可以在此下载浙江省地图数据。</a></p>
<h3 id="搭建本地服务（window环境）"><a href="#搭建本地服务（window环境）" class="headerlink" title="搭建本地服务（window环境）"></a>搭建本地服务（window环境）</h3><p>地图准备好后，就需要搭建我们本地的服务了。这里注意，搭建本地服务需要准备好我们的本地环境，因我Graphhopper是基于java开发的，因此我们需要下载<strong>Java JDK</strong>，从Oracle官网下载并安装JDK，并配置好环境变量。然后是maven，同样下载安装配置环境变量，可以参考<a href="https://blog.csdn.net/qq_42006801/article/details/115640020">Maven安装与配置（详细步骤）_apachemaven安装与配置_liyitongxue的博客-CSDN博客</a>。</p>
<h3 id="下载Graphhopper"><a href="#下载Graphhopper" class="headerlink" title="下载Graphhopper"></a>下载Graphhopper</h3><p>然后我们可以开始下载Graphhopper，这里可以直接在GitHub搜索Graphhopper即可。</p>
<p><img src="/../images/ac2d62d546e648f9a608f0b487bc035e.png" alt="在这里插入图片描述"></p>
<p>这里建议<strong>不要</strong>直接克隆master分支，可以选择<strong>stable</strong>分支（踩了好多坑之后，才发现master分支好像没有graphhopper.sh文件，这个文件在后面很重要！）</p>
<p><img src="/../images/c89e702ea5bf4b46af6f490fa46fbad9.png" alt="在这里插入图片描述"></p>
<p>将该分支克隆到本地之后，会发现里面有一个文件名为config-example.yml的文件，采用文本编辑器打开，将文件开头数据修改成自己的文件路径，端口选择8989端口。<br><img src="/../images/f31c651486a9435fa42f660df98c3db4.png" alt="在这里插入图片描述"></p>
<p>到这里有些教程会让你直接在命令行执行以下命令构建路网数据，生成索引文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./graphhopper.sh build</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./graphhopper.sh web</span><br></pre></td></tr></table></figure>

<p>然后是打开网址<a href="http://127.0.0.1:8989即可。">http://127.0.0.1:8989即可。</a></p>
<p>但是对于像我这样的小白，这里可能会遇到很多问题，这里我们逐一展开解决（每一个都是让人心态崩溃的坑）。</p>
<h3 id="坑1-本地服务问题"><a href="#坑1-本地服务问题" class="headerlink" title="坑1-本地服务问题"></a>坑1-本地服务问题</h3><p>首先是本地服务问题，一般直接在浏览器里输入<a href="http://127.0.0.1:8989是会显示拒绝访问，这里的域名是本地服务器,这一般是由于没安装IIS服务。解决方法很简单：在控制面板/程序/启用或关闭Windows功能中选择以下两项安装。将两项全点上就行。如果输入ip地址http://127.0.0.1显示以下界面，就算是跳出这个坑了。">http://127.0.0.1:8989是会显示拒绝访问，这里的域名是本地服务器,这一般是由于没安装IIS服务。解决方法很简单：在控制面板/程序/启用或关闭Windows功能中选择以下两项安装。将两项全点上就行。如果输入ip地址http://127.0.0.1显示以下界面，就算是跳出这个坑了。</a><br><img src="/../images/0177ed1aa0c949d79299f093a54f223b.png" alt="在这里插入图片描述"><br><img src="/../images/3587bb7a924949f98ad55730f4b02f1d.png" alt="在这里插入图片描述"></p>
<h3 id="坑2-cygwin问题"><a href="#坑2-cygwin问题" class="headerlink" title="坑2-cygwin问题"></a>坑2-cygwin问题</h3><p>下一个坑是Cygwin，这里同样是下载安装。<a href="https://blog.csdn.net/hu_yinghui/article/details/125263154">windows下安装Cygwin详细教程_快乐小胡！的博客-CSDN博客</a></p>
<h3 id="坑3-wget问题"><a href="#坑3-wget问题" class="headerlink" title="坑3-wget问题"></a>坑3-wget问题</h3><p>如果到这里还是显示8989端口拒绝访问，可能是wget没有下载安装。这里的wget是linux里面的下载工具，我们在windows下可以搜索wget for windows下载安装。<a href="https://zhuanlan.zhihu.com/p/28826000">Wget for windows——优雅地实现批量下载 - 知乎 (zhihu.com)</a></p>
<h3 id="本地服务，启动！"><a href="#本地服务，启动！" class="headerlink" title="本地服务，启动！"></a>本地服务，启动！</h3><p>解决完以上问题之后，终于可以进行搭建我们自己的本地服务了。但是如果还是按照有些教程上进入graphhopper根目录后输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./graphhopper.sh build</span><br></pre></td></tr></table></figure>

<p>还是会出现问题，会跳出以下窗口，几十秒后又会自动关闭。</p>
<p>这行命令的作用是：下载所需的依赖，构建GraphHopper的路网数据，并生成索引文件。经过多方查找资料，发现应该输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先进入到graphhopper目录下,再执行以下语句</span></span><br><span class="line">./graphhopper.sh -a web -i china-latest.osm.pbf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">china-latest.osm.pdf是下载的路图</span></span><br></pre></td></tr></table></figure>

<p>跳出以下界面则配置完成</p>
<p><img src="/../images/9eda1b49f747438e8bfd090470baedbe.png" alt="在这里插入图片描述"><br>如果报以下错误</p>
<p><code>-bash: ./graphhopper.sh: /bin/bash^M: bad interpreter: No such file or directory</code></p>
<p>可以尝试使用以下方式进行解决</p>
<p><code>sed -i &#39;s/\r$//&#39; ./graphhopper.sh #解决linux 跟Windows 对于换行符不同的区别</code></p>
<p>如果不成功可能是因为解析的地图数据过大导致内存溢出发生错误：<br>可以在执行启动之前先扩大内存</p>
<p><code>export JAVA_OPTS=&quot;-Xmx4g -Xms4g&quot;#加大至4G内存</code></p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>到此，所有操作全部完成，在浏览器输入<a href="http://127.0.0.1:8989即可进入以下网页，进行路径规划。">http://127.0.0.1:8989即可进入以下网页，进行路径规划。</a></p>
<p>也可以通过python调用本地服务器接口，将结果传入python程序，进行后续一系列操作。<br><img src="/../images/87a27c28e3a54dae905273dfc1747aed.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1:8989/route?point=27.939648,120.934602&amp;point=27.936577,120.931941&amp;profile=car&amp;layer=OpenStreetMap&#x27;</span></span><br><span class="line">response = requests.get(url)  </span><br><span class="line">info = response.json()[<span class="string">&#x27;paths&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(info)  <span class="comment"># 获取json</span></span><br><span class="line"><span class="comment"># print(info[&#x27;distance&#x27;])  # 获取路径距离,单位为米</span></span><br><span class="line"><span class="comment"># print(info[&#x27;time&#x27;])  # 获取路径时间，单位为毫秒</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(info[<span class="string">&#x27;distance&#x27;</span>]/<span class="number">1000</span>,<span class="number">2</span>))  <span class="comment"># 单位转为千米</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(info[<span class="string">&#x27;time&#x27;</span>]/(<span class="number">60</span>*<span class="number">1000</span>),<span class="number">0</span>))  <span class="comment"># 单位转为分钟</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6955757106750292004">本地百度瓦片+GraphHopper搭建离线路径规划 - 掘金 (juejin.cn)</a></p>
<p><a href="https://blog.csdn.net/wml00000/article/details/84030182">基于Leaflet和GraphHopper实现离线路径规划_graphhooper_wml00000的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/wml00000/article/details/84108694">基于GraphHopper搭建离线路径规划服务并可视化_graph 路径规划_wml00000的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/Sysdark/article/details/111298945">离线路径规划服务Graphhopper_RobotMartin的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_42006801/article/details/115640020">Maven安装与配置（详细步骤）_apachemaven安装与配置_liyitongxue的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_42006801/article/details/115640020">Maven安装与配置（详细步骤）_apachemaven安装与配置_liyitongxue的博客-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/read/cv22391502/">实现离线地图导航第一步！windows本地搭建GraphHopper服务 - 哔哩哔哩 (bilibili.com)</a></p>
]]></content>
      <tags>
        <tag>车辆路径规划</tag>
      </tags>
  </entry>
  <entry>
    <title>列生成算法简介</title>
    <url>/2024/05/12/%E5%88%97%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h3 id="1-什么是列生成"><a href="#1-什么是列生成" class="headerlink" title="1. 什么是列生成"></a>1. 什么是列生成</h3><p>列生成算法是一种用于解决大规模线性规划问题的高效算法，它基于单纯形法的思想，通过求解子问题来找到可以进基的非基变量。在列生成算法中，每个变量都代表一列，因此称为列生成算法。该算法的优点在于其高效的计算性能和较好的收敛性，适用于处理大规模、复杂的线性规划问题。</p>
<p>在列生成算法的迭代过程中，因为会不断有变量入基，所以会导致限制主问题的列不断增加，所以叫做列生成算法。</p>
<h3 id="2-列生成的应用范围"><a href="#2-列生成的应用范围" class="headerlink" title="2. 列生成的应用范围"></a>2. 列生成的应用范围</h3><p>列生成被广泛应用于调度问题、切割问题、车辆路径问题、选址问题等。 该算法的优点在于其高效的计算性能和较好的收敛性，适用于处理大规模、复杂的线性规划问题。对于变量数目很多的线性优化问题，单纯形法速度很慢，可以用到列生成方法来加快求解速度。</p>
<h3 id="3-列生成的原理"><a href="#3-列生成的原理" class="headerlink" title="3. 列生成的原理"></a>3. 列生成的原理</h3><p>基本思路如下：</p>
<p>1、先把原问题限制到一个规模更小的限制主问题，在限制主问题的基础上用单纯形法求解，但此时的解并不是主问题的最优解。</p>
<p>2、通过一个子问题去检查那些未被考虑的变量中是否有使得reduced cost小于0的？如果有，就把这个变量的相关系数列加入到限制主问题的系数矩阵中，回到第一步。</p>
<p>经过反复迭代，知道子问题的reduced cost rate大于等于0，那么主问题就求到了最优解。</p>
<h3 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4. 基本概念"></a>4. 基本概念</h3><h4 id="受限主问题"><a href="#受限主问题" class="headerlink" title="受限主问题"></a>受限主问题</h4><p>$$<br>min(y_1+y_2+\cdots+y_k)<br>$$</p>
<p>$s.t.$<br>$$<br>R_1: a_{11}y_1+\cdots+a_{1k}y_k \geq b_1<br>$$<br>$$<br>R_2: a_{21}y_1+\cdots+a_{2k}y_k \geq b_2<br>$$</p>
<p>$$<br>\cdots<br>$$</p>
<p>$$<br>R_m:a_{m1}y_1+\cdots+a_{mk}y_k \geq b_m<br>$$</p>
<p>就是从主问题中选取k个变量构成的松弛问题。</p>
<h4 id="子问题"><a href="#子问题" class="headerlink" title="子问题"></a>子问题</h4><p>通过求解RMP问题或者RMP对偶问题后，得到了想要的$c_BB^{-1}$以后，子问题就是通过$\sigma_j &#x3D; c_j - c_BB^{-1}a_j$</p>
<p>这条公式，在$y_{k+1}、y_m$中寻找检验数为负且最小的变量，将变量对应的那一列添加到RMP中。</p>
<h2 id="列生成算法实现"><a href="#列生成算法实现" class="headerlink" title="列生成算法实现"></a>列生成算法实现</h2><h3 id="案例求解"><a href="#案例求解" class="headerlink" title="案例求解"></a>案例求解</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>cutting stock problem是采用列生成算法求解的经典案例。该问题如下：有一些纸筒，每个纸筒长度为16m。顾客需要25个3m，20个6m，15个7m的纸筒。要求在满足顾客需求的情况下，裁剪的纸筒数最小。</p>
<h4 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h4><p>可以采用启发式算法求解到一个初始解如下：</p>
<p>5个纸筒采用切割方案1：3，3，3，3，3；</p>
<p>10个纸筒采用切割方案2：6，6；</p>
<p>8个纸筒采用切割方案3：7，7；</p>
<p>总计23个纸筒。可以看出，采用23个纸筒是一定可以满足要求的，这是问题的一个上界（upper bound）。</p>
<p>该问题可行的切割方案很多，我们可以采用P表示所有可行裁剪方案的集合，里面的方案总数为n（这里的n并不需要知道其确切取值，一般来说n是一个很大的数）。$a_{ij}$表示第$j$种方案里类别$i$的个数，$y_j$表示第$j$种方案的选择个数。建立数学模型如下：<br>$$<br>min \quad y_1+y_2+\cdots+y_n<br>$$<br>$s.t.$<br>$$<br>R1:a_{11}y_1 + \cdots + a_{1n}y_n \geq 25<br>$$<br>$$<br>R2:a_{21}y_1 + \cdots + a_{2n}y_n \geq 20<br>$$</p>
<p>$$<br>R3:a_{31}y_1 + \cdots + a_{3n}y_n \geq 15<br>$$</p>
<p>约束中的每一列对应的是一种切割方案，前三种方案已知，就是我们前面采用启发式算法求解的三种方案。其它的$n-3$种切割方案未知。</p>
<h4 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h4><h5 id="第一轮循环"><a href="#第一轮循环" class="headerlink" title="第一轮循环"></a>第一轮循环</h5><p>首先从上述模型中选出一些列，构成问题的限制主问题，这里我们选取前3列。则限制主问题如下<br>$$<br>min \quad y_1 + y_2 + y_3<br>$$<br>$$<br>5y_1 + 0 y_2 + 0y_3 \geq 25<br>$$</p>
<p>$$<br>0y_1 + 2 y_2 + 0y_3 \geq 20<br>$$</p>
<p>$$<br>0y_1 + 0 y_2 + 2y_3 \geq 15<br>$$</p>
<p>使用python+gurobi求解上述线性规划问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gurobipy <span class="keyword">as</span> gp</span><br><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line">m = gp.Model(<span class="string">&#x27;column generation&#x27;</span>)</span><br><span class="line">y = m.addVars(<span class="number">3</span>,vtype = gp.GRB.CONTINUOUS,name=<span class="string">&#x27;y&#x27;</span>,lb=<span class="number">0</span>)</span><br><span class="line">m.addConstr(<span class="number">5</span>*y[<span class="number">0</span>] &gt;= <span class="number">25</span>)</span><br><span class="line">m.addConstr(<span class="number">2</span>*y[<span class="number">1</span>] &gt;= <span class="number">20</span>)</span><br><span class="line">m.addConstr(<span class="number">2</span>*y[<span class="number">2</span>] &gt;= <span class="number">15</span>)</span><br><span class="line">m.setObjective(y[<span class="number">0</span>]+y[<span class="number">1</span>]+y[<span class="number">2</span>],gp.GRB.MINIMIZE)</span><br><span class="line">m.setParam(<span class="string">&#x27;OutputFlag&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">m.optimize()</span><br><span class="line">m.getAttr(gp.GRB.Attr.Pi)</span><br></pre></td></tr></table></figure>

<p>可以求解出对偶变量的取值为$c_BB^{-1}&#x3D;[0.2,0.5,0.5]$。现在要找一列加入RMP，但是并不知道其取值，我们将其记作$\alpha_4 &#x3D; [a_{14},a_{24},a_{34}]^T$。得到非基变量的检验数为$\sigma_4 &#x3D; c_4 - c_BB^{-1}\alpha_4 &#x3D; 1-0.2\alpha_{14} - 0.5\alpha_{24} - 0.5\alpha_{34}$</p>
<p>从而构造子问题如下：<br>$$<br>min(1-0.2a_{14} - 0.5a_{24} - 0.5a_{34})<br>$$<br>$s.t.$<br>$$<br>3a_{14}+6a_{24}+7a_{34} \leq 16<br>$$<br>$$<br>a_{ij} \in Z<br>$$</p>
<p>同样采用python+gurobi求解上述问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gurobipy <span class="keyword">as</span> gp</span><br><span class="line">m1 = gp.Model(<span class="string">&#x27;subproblem&#x27;</span>)</span><br><span class="line">a = m1.addVars(<span class="number">3</span>,vtype=gp.GRB.INTEGER,lb=<span class="number">0</span>,name=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">m1.setObjective(<span class="number">1</span>-<span class="number">0.2</span>*a[<span class="number">0</span>]-<span class="number">0.5</span>*a[<span class="number">1</span>]-<span class="number">0.5</span>*a[<span class="number">2</span>])</span><br><span class="line">m1.addConstr(<span class="number">3</span>*a[<span class="number">0</span>]+<span class="number">6</span>*a[<span class="number">1</span>]+<span class="number">7</span>*a[<span class="number">2</span>] &lt;= <span class="number">16</span>)  <span class="comment"># 列生成规则</span></span><br><span class="line">m1.setParam(<span class="string">&#x27;OutputFlag&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">m1.optimize()</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>].x,a[<span class="number">1</span>].x,a[<span class="number">2</span>].x)</span><br></pre></td></tr></table></figure>

<p>求解出$\alpha_4 &#x3D; [1,2,0]^T$，检验数为$\sigma_4 &#x3D; c_4 - c_BB^{-1}\alpha_4 &#x3D; 1-0.2\times1 - 0.5\times2 - 0.5\times0 &#x3D; -0.2 &lt; 0$，因为检验数小于0，所以需要将$y_4$入基，添加到主问题中，开始第二轮迭代。</p>
<h5 id="第二轮循环"><a href="#第二轮循环" class="headerlink" title="第二轮循环"></a>第二轮循环</h5><p>加入$y_4$后，限制主问题变为<br>$$<br>min \quad y_1 + y_2 + y_3 + y_4<br>$$<br>$$<br>5y_1 + 0 y_2 + 0y_3 + 1y_4\geq 25<br>$$</p>
<p>$$<br>0y_1 + 2 y_2 + 0y_3 + 2y_4 \geq 20<br>$$</p>
<p>$$<br>0y_1 + 0 y_2 + 2y_3 + 0y_4 \geq 15<br>$$</p>
<p>限制主问题与之前相比，多了一列，所以被称为列生成算法。求解该限制主问题，其对偶变量取值为$c_BB^{-1}&#x3D;[0.2,0.4,0.5]$，下一个需要入基的变量记为$\alpha_5 &#x3D; [a_{15},a_{25},a_{35}]^T$，构造子问题如下<br>$$<br>min(1-0.2a_{15} - 0.4a_{25} - 0.5a_{35})<br>$$<br>$s.t.$<br>$$<br>3a_{15}+6a_{25}+7a_{35} \leq 16<br>$$<br>$$<br>a_{ij} \in Z<br>$$</p>
<p>采用同样方法求解该子问题，得到结果$\alpha_5 &#x3D; [3,0,1]^T$，检验数为$\sigma_5 &#x3D; c_5 - c_BB^{-1}\alpha_5 &#x3D; 1-0.2\times3 - 0.4\times0 - 0.5\times1 &#x3D; -0.1 &lt; 0$，因为检验数小于0，所以需要将$y_5$入基，添加到主问题中，开始下一轮迭代。</p>
<h5 id="第三轮循环"><a href="#第三轮循环" class="headerlink" title="第三轮循环"></a>第三轮循环</h5><p>加入$y_5$后，限制主问题变为<br>$$<br>min \quad y_1 + y_2 + y_3 + y_4 + y_5<br>$$<br>$$<br>5y_1 + 0 y_2 + 0y_3 + 1y_4 + 3y_5\geq 25<br>$$</p>
<p>$$<br>0y_1 + 2 y_2 + 0y_3 + 2y_4 + 0y_5 \geq 20<br>$$</p>
<p>$$<br>0y_1 + 0 y_2 + 2y_3 + 0y_4 + 1y_5 \geq 15<br>$$</p>
<p>还是求解限制主问题，其对偶变量取值为$c_BB^{-1}&#x3D;[0.1667,0.4167,0.5]$，下一个需要入基的变量记为$\alpha_6 &#x3D; [a_{16},a_{26},a_{36}]^T$，构造子问题如下<br>$$<br>min(1-0.1667a_{16} - 0.4167a_{26} - 0.5a_{36})<br>$$<br>$s.t.$<br>$$<br>3a_{16}+6a_{26}+7a_{36} \leq 16<br>$$<br>$$<br>a_{ij} \in Z<br>$$</p>
<p>求得结果$\alpha_5 &#x3D; [1,1,1]^T$，检验数$\sigma_6&#x3D; c_6 - c_BB^{-1}\alpha_6 &#x3D; 1-0.1667\times1- 0.4167\times1 - 0.5\times1 &#x3D; -0.08333 &lt; 0$，所以将$y_6$代入</p>
<h5 id="第四轮循环"><a href="#第四轮循环" class="headerlink" title="第四轮循环"></a>第四轮循环</h5><p>加入$y_6$后，限制主问题变为<br>$$<br>min \quad y_1 + y_2 + y_3 + y_4 + y_5 + y_6<br>$$<br>$$<br>5y_1 + 0 y_2 + 0y_3 + 1y_4 + 3y_5 + y_6\geq 25<br>$$</p>
<p>$$<br>0y_1 + 2 y_2 + 0y_3 + 2y_4 + 0y_5 + y_6 \geq 20<br>$$</p>
<p>$$<br>0y_1 + 0 y_2 + 2y_3 + 0y_4 + 1y_5 + y_6 \geq 15<br>$$</p>
<p>还是求解限制主问题，其对偶变量取值为$c_BB^{-1}&#x3D;[0.2,0.4,0.4]$，下一个需要入基的变量记为$\alpha_7 &#x3D; [a_{17},a_{27},a_{37}]^T$，构造子问题如下<br>$$<br>min(1-0.2a_{17} - 0.4a_{27} - 0.4a_{37})<br>$$<br>$s.t.$<br>$$<br>3a_{17}+6a_{27}+7a_{37} \leq 16<br>$$<br>$$<br>a_{ij} \in Z<br>$$</p>
<p>求得结果$\alpha_5 &#x3D; [5,0,0]^T$，检验数$\sigma_6&#x3D; c_6 - c_BB^{-1}\alpha_6 &#x3D; 1-0.2\times5- 0.4\times0 - 0.4\times0 &#x3D; 0$，结束迭代，此时列生成算法结束。</p>
<p>此时，我们将$y_7$代入模型，此时求解结果就是最优解。</p>
<p>求解出最优解为$y&#x3D;[1,0,0,3,1,14,0]$，此时目标函数值为19。</p>
<p>所以我们得到的最终切割方案为</p>
<table>
<thead>
<tr>
<th align="center">方案</th>
<th align="center">该方案的数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">3，3，3，3，3，3</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3，6，6</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3，3，3，7</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3，6，7</td>
<td align="center">14</td>
</tr>
</tbody></table>
<h2 id="完整版列生成代码"><a href="#完整版列生成代码" class="headerlink" title="完整版列生成代码"></a>完整版列生成代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gurobipy <span class="keyword">as</span> grb</span><br><span class="line"><span class="keyword">from</span> gurobipy <span class="keyword">import</span> GRB</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">master_problem</span>(<span class="params">column, vtype</span>):</span><br><span class="line">    m = grb.Model()</span><br><span class="line">    x = m.addMVar(shape=column.shape[<span class="number">1</span>], lb=<span class="number">0</span>, vtype=vtype)</span><br><span class="line">    m.addConstr(lhs=column @ x &gt;= demand_number_array)</span><br><span class="line">    m.setObjective(x.<span class="built_in">sum</span>(), GRB.MINIMIZE)</span><br><span class="line">    m.optimize()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> vtype == GRB.CONTINUOUS:</span><br><span class="line">        <span class="keyword">return</span> np.array(m.getAttr(<span class="string">&#x27;Pi&#x27;</span>, m.getConstrs()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> m.objVal, np.array(m.getAttr(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restricted_lp_master_problem</span>(<span class="params">column</span>):</span><br><span class="line">    <span class="keyword">return</span> master_problem(column, GRB.CONTINUOUS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restricted_ip_master_problem</span>(<span class="params">column</span>):</span><br><span class="line">    <span class="keyword">return</span> master_problem(column, GRB.INTEGER)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_subproblem</span>(<span class="params">kk</span>):</span><br><span class="line">    m = grb.Model()</span><br><span class="line">    x = m.addMVar(shape=kk.shape[<span class="number">0</span>], lb=<span class="number">0</span>, vtype=GRB.INTEGER)</span><br><span class="line">    m.addConstr(lhs=demand_width_array @ x &lt;= roll_width)</span><br><span class="line">    m.setObjective(<span class="number">1</span> - kk @ x, GRB.MINIMIZE)</span><br><span class="line">    m.optimize()</span><br><span class="line"></span><br><span class="line">    flag_new_column = m.objVal &lt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> flag_new_column:</span><br><span class="line">        new_column = m.getAttr(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_column = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> flag_new_column, new_column</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">roll_width = np.array(<span class="number">16</span>)</span><br><span class="line">demand_width_array = np.array([<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">demand_number_array = np.array([<span class="number">25</span>, <span class="number">20</span>, <span class="number">15</span>])</span><br><span class="line">initial_cut_pattern = np.diag(np.floor(roll_width / demand_width_array))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag_new_cut_pattern = <span class="literal">True</span></span><br><span class="line">new_cut_pattern = <span class="literal">None</span></span><br><span class="line">cut_pattern = initial_cut_pattern</span><br><span class="line"><span class="keyword">while</span> flag_new_cut_pattern:</span><br><span class="line">    <span class="keyword">if</span> new_cut_pattern:</span><br><span class="line">        cut_pattern = np.column_stack((cut_pattern, new_cut_pattern))</span><br><span class="line">    kk = restricted_lp_master_problem(cut_pattern)</span><br><span class="line">    flag_new_cut_pattern, new_cut_pattern = knapsack_subproblem(kk)</span><br><span class="line"></span><br><span class="line">minimal_stock, optimal_number = restricted_ip_master_problem(cut_pattern)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;************************************************&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;parameter:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;roll_width: <span class="subst">&#123;roll_width&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;demand_width_array: <span class="subst">&#123;demand_width_array&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;demand_number_array: <span class="subst">&#123;demand_number_array&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;minimal_stock: <span class="subst">&#123;minimal_stock&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;cut_pattern: <span class="subst">&#123;cut_pattern&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;optimal_number: <span class="subst">&#123;optimal_number&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">************************************************</span><br><span class="line">roll_width:16</span><br><span class="line">demand_width_array:[3,6,7]</span><br><span class="line">demand_number_array:[25,20,15]</span><br><span class="line">minimal_stock:19.0</span><br><span class="line">cut_pattern:[[5,0,0,1,3,1]</span><br><span class="line">[0,2,0,2,0,1]</span><br><span class="line">[0,0,2,0,1,1]]</span><br><span class="line">optimal_number:[1,0,0,3,1,14]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>精确算法</tag>
      </tags>
  </entry>
  <entry>
    <title>市井烟火气，甚抚凡人心</title>
    <url>/2024/05/13/%E5%B8%82%E4%BA%95%E7%83%9F%E7%81%AB%E6%B0%94%EF%BC%8C%E7%94%9A%E6%8A%9A%E5%87%A1%E4%BA%BA%E5%BF%83/</url>
    <content><![CDATA[<p>很多年没有逛过菜市场了</p>
<p>人群中穿梭着各色人等，来来往往。</p>
<p>放慢脚步，重新思考生活的意义。</p>
<p>每日辛苦奔波，所求为何？</p>
<p><img src="/../images/%E5%9C%B0%E4%B8%8B%E9%80%9A%E9%81%93.jpg" alt="图文无关"></p>
]]></content>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title>雨天emo</title>
    <url>/2024/05/27/%E9%9B%A8%E5%A4%A9emo/</url>
    <content><![CDATA[<p><img src="/../images/IMG_20240522_190921.jpg" alt="IMG_20240522_190921"></p>
<center>不要哭我最亲爱的人</center>

<center>我最好的玩伴</center>

<center>时空是个圆圈</center>

<center>直行或是转弯</center>

<center>我们最终都会相见。</center>





<p>愿所有想见的人，还能再见，哪怕是等上一个庞加莱回归。</p>
<p>注：</p>
<p>庞加莱回归：任何粒子在经历一个漫长的时间之后必然能回到其无限接近其初始位置的位置（但是不能回到原来位置，只能无限接近），尽管这个时间的长度远远超出我们所能想，但是它必然会实现，这样一个周期就称为一个庞加莱回归。</p>
]]></content>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title>灰靶决策</title>
    <url>/2024/06/01/%E7%81%B0%E9%9D%B6%E5%86%B3%E7%AD%96/</url>
    <content><![CDATA[<h1 id="多目标加权智能灰靶决策模型"><a href="#多目标加权智能灰靶决策模型" class="headerlink" title="多目标加权智能灰靶决策模型"></a>多目标加权智能灰靶决策模型</h1><h2 id="1-灰色决策模型"><a href="#1-灰色决策模型" class="headerlink" title="1. 灰色决策模型"></a>1. 灰色决策模型</h2><p><strong>定义1</strong> 事件、对策、目标、效果称为灰色决策四要素.</p>
<p><strong>定义2</strong> 设$A&#x3D;{a_1,a_2,\cdots,a_n}$为研究范围内事件的全体，称为该研究范围内的事件集，$a_i(i&#x3D;1,2,\cdots,n)$为第$i$个事件，所有可能对策全体称为对策集，记作$B&#x3D;{b_1,b_2,\cdots,b_m}$，其中$b_j(j&#x3D;1,2,\cdots,m)$为第$j$种对策.</p>
<p><strong>定义3</strong> 事件集A与对策集B的乘积$A\times B &#x3D; {(a_i,b_j)|a_i\in A,b_j\in B}$称为决策方案集，记作$S&#x3D; A\times B$.对于任意$a_i \in A, b_j \in B$，称$(a_i,b_j)$为一个决策方案，记作$s_{ij}&#x3D;(a_i,b_j)$.</p>
<p><strong>定义4</strong> 设$$U^{(k)}&#x3D;(u_{ij}^{(k)})&#x3D;\begin{bmatrix}u_{11}^{(k)}&amp;\dots&amp;u_{1m}^{(k)}\\vdots&amp;\ddots&amp;\vdots\u_{1n}^{(k)}&amp;\dots&amp;u_{nm}^{(k)}\end{bmatrix}$$为决策方案集$S$在目标下的效果样本矩阵.</p>
<ol>
<li>设$k$为效益型目标,希望目标效果的样本值越大越优.$k$目标下的灰靶为$u_{ij}^{(k)}\in[u_{i_0j_0}^{(k)},\max_i\max_j{u_{ij}^{(k)}}]$即$u_{i_0j_0}^{(k)}$为k目标的效果临界值,称$r_{ij}^{(k)}&#x3D;\frac{u_{ij}^{(k)}-u_{i_0j_0}^{(k)}}{\max_i\max_j{u_{ij}^{(k)}}-u_{i_0j_0}^{(k)}}$为效益型目标效果测度函数.</li>
<li>设$k$为成本型目标，希望目标效果的样本值越小越优.设$k$目标下的灰靶为$u_{ij}^{(k)}\in[u_{i_0j_0}^{(k)},\min_i\min_j{u_{ij}^{(k)}}]$即$u_{i_0j_0}^{(k)}$为k目标的效果临界值,称$r_{ij}^{(k)}&#x3D;\frac{u_{i_0j_0}^{(k)}-u_{ij}^{(k)}}{u_{i_0j_0}^{(k)}-\min_i\min_j{u_{ij}^{(k)}}}$为成本型目标效果测度函数.</li>
<li>设$k$为适中型目标,希望目标效果的样本值越 接近一个适中值$A$越优.设$k$目标下的灰靶为$u_{ij}^{(k)}\in[A-u_{i_0j_0}^{(k)},A+u_{i_0j_0}^{(k)}]$即$A-u_{i_0j_0}^{(k)}$，$A+u_{i_0j_0}^{(k)}$，分别为k目标下的下限效果临界值和上限效果临界值.</li>
</ol>
<p>​        ① 当$u_{ij}^{(k)}\in[A-u_{i_0j_0}^{(k)},A]$时，称$r_{ij}^{(k)}&#x3D;\frac{u_{ij}^{(k)}-A+u_{i_0j_0}^{(k)}}{u_{i_0j_0}^{(k)}}$为适中型目标下限效果测度函数;</p>
<p>​        ②当$u_{ij}^{(k)}\in[A,A+u_{i_0j_0}^{(k)}]$时，称$r_{ij}^{(k)}&#x3D;\frac{A+u_{ij}^{(k)}-u_{i_0j_0}^{(k)}}{u_{i_0j_0}^{(k)}}$为适中型目标上限效果测度函数;</p>
<p><strong>定义5</strong>  当$k$目标效果值$r_{ij}^k\in[0,1]$时,称$k$目标中靶,$k$目标为加分因素;当$k$目标效果值$r_{ij}^k\in[-1,0]$时,称$k$目标脱靶,$k$目标为减分因素.</p>
<p><strong>定义6</strong> 设$\eta_k(k&#x3D;1,2,\cdots,s)$为目标$k$的决策权，$\sum_{k&#x3D;1}^s\eta_k&#x3D;1$，称$R^{(k)}&#x3D;(r_{ij}^{(k)})&#x3D;\begin{bmatrix}r_{11}^{(k)}&amp;\dots&amp;r_{1m}^{(k)}\\vdots&amp;\ddots&amp;\vdots\r_{1n}^{(k)}&amp;\dots&amp;r_{nm}^{(k)}\end{bmatrix}$为决策方案集S在k目标下的一致效果测度矩阵.对于$s_{ij}\in S$,称$r_{ij}&#x3D;\sum_{k&#x3D;1}^s\eta_kr_{ij}^{(k)}$为决策方案的综合效果测度函数，同时也称$R&#x3D;(r_{ij})&#x3D;\begin{bmatrix}r_{11}&amp;\dots&amp;r_{1m}\\vdots&amp;\ddots&amp;\vdots\\r_{1n}&amp;\dots&amp;r_{nm}\end{bmatrix}$为综合效果测度矩阵.</p>
<p>**定义7 ** 若$\max_{1\leqslant j\leqslant m}{r_{ij}}&#x3D;r_{ij_0}$则称$b_{j_0}$为事件$a_i$的最优对策；若$\max_{1\leqslant j\leqslant n}{r_{ij}}&#x3D;r_{i_0j}$则称$a_{i_0}$为事件$b_j$的最优事件；若$\max_{1\leqslant i\leqslant n}\max_{1\leqslant j\leqslant m}{r_{ij}}&#x3D;r_{i_0j_0}$则称$s_{i_0j_0}$为最优局势即方案.</p>
<h2 id="2-多目标加权智能灰靶决策模型的建模流程"><a href="#2-多目标加权智能灰靶决策模型的建模流程" class="headerlink" title="2. 多目标加权智能灰靶决策模型的建模流程"></a>2. 多目标加权智能灰靶决策模型的建模流程</h2><p>详细的多目标加权智能灰靶决策模型的建模算法流程如图所示.</p>
<img src="../images/image-20240601142847658.png" alt="image-20240601142847658" style="zoom: 67%;" />

]]></content>
      <tags>
        <tag>灰色系统</tag>
      </tags>
  </entry>
</search>
